"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _path=_interopRequireDefault(require("path")),_cosmiconfig=require("cosmiconfig"),_toCamelCase=_interopRequireDefault(require("to-camel-case")),_mergeOptions=_interopRequireDefault(require("merge-options")),_normalizePath=_interopRequireDefault(require("normalize-path")),_fastGlob=_interopRequireDefault(require("fast-glob"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var _default=({input,flags={}})=>{var _config2,_config3,_config4,_config5,_output,_config6,_config7,_use;const explorer=(0,_cosmiconfig.cosmiconfigSync)("posthtml");let{config,use,options={},output,root="./",skip=[],allInOutput=!1}=flags;if(config&&({config}=explorer.load(config)),use){var _config$plugins,_config;const configPluginOptions=null!==(_config$plugins=null===(_config=config)||void 0===_config?void 0:_config.plugins)&&void 0!==_config$plugins?_config$plugins:{};// Plugins defined via CLI options take precedence over the ones from config file.
// Add the remaining plugins if there is any.
if(use=[].concat(use).reduce((cfg,name)=>{let cliOptions=flags[(0,_toCamelCase.default)(name)],configOptions=configPluginOptions[name];// We merge this way because options can be both strings and objects.
const merged=(0,_mergeOptions.default)({[name]:configOptions},{[name]:cliOptions||{}});// Assigning as we loop `use` makes sure that the order in cfg.plugins is correct.
return cfg.plugins[name]=merged[name],configOptions&&delete configPluginOptions[name],cfg},{plugins:{}}),config&&config.plugins){for(let name in configPluginOptions)configPluginOptions[name]&&(use.plugins[name]=configPluginOptions[name]);// Now all the plugins are in `use.plugins`.
// Delete `config.plugins` for correct merging later: mergeOptions(config, {...}, use)
delete config.plugins}}if(!config&&!use){const search=explorer.search();config=null===search||void 0===search?void 0:search.config}if(null!==(_config2=config)&&void 0!==_config2&&_config2.root&&(root=config.root),null!==(_config3=config)&&void 0!==_config3&&_config3.allInOutput&&(allInOutput=config.allInOutput),null!==(_config4=config)&&void 0!==_config4&&_config4.skip&&(skip=skip.concat(config.skip)),input=[].concat(input&&0<input.length?input:null===(_config5=config)||void 0===_config5?void 0:_config5.input).filter(Boolean).map(file=>{const ignoreFile=file.startsWith("!");let ignoreSymbol="";return ignoreFile&&(ignoreSymbol="!",file=file.slice(1)),`${ignoreSymbol}${(0,_normalizePath.default)(_path.default.join(_path.default.resolve(root),file))}`}),0===input.length)throw new TypeError("input files not found");return output=null!==(_output=output)&&void 0!==_output?_output:null===(_config6=config)||void 0===_config6?void 0:_config6.output,output&&(output=(0,_normalizePath.default)(output)),skip=_fastGlob.default.sync(skip,{cwd:_path.default.resolve(root)}).map(file=>(0,_normalizePath.default)(_path.default.join(_path.default.resolve(root),file))),(0,_mergeOptions.default)(null!==(_config7=config)&&void 0!==_config7?_config7:{},{input,output,options,root,allInOutput,skip},null!==(_use=use)&&void 0!==_use?_use:{})};exports.default=_default;